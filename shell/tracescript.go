// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

package shell

import (
	"encoding/binary"
	"fmt"
	"net"
	"strings"
)

// ScriptGenerator generates bpftrace scripts for network tracing.
// SECURITY: All IP addresses are converted to hex representation to prevent injection.
type ScriptGenerator struct {
	config TraceConfig
}

// NewScriptGenerator creates a new script generator with the given config.
func NewScriptGenerator(config TraceConfig) *ScriptGenerator {
	return &ScriptGenerator{config: config}
}

// Generate creates the complete bpftrace script.
func (g *ScriptGenerator) Generate() string {
	var sb strings.Builder

	// Write script header
	sb.WriteString(g.generateHeader())

	// Write BEGIN block
	sb.WriteString(g.generateBeginBlock())

	// Write tracepoints
	sb.WriteString(g.generateDropTracepoint())

	// Write END block
	sb.WriteString(g.generateEndBlock())

	return sb.String()
}

// generateHeader creates the script header with comments.
func (g *ScriptGenerator) generateHeader() string {
	return `#!/usr/bin/env bpftrace
/*
 * Network Drop Tracer - Generated by retina nettrace
 * Traces packet drops with reason codes
 */

`
}

// generateBeginBlock creates the BEGIN block with initialization.
func (g *ScriptGenerator) generateBeginBlock() string {
	var sb strings.Builder

	sb.WriteString("BEGIN {\n")

	if g.config.OutputJSON {
		sb.WriteString(`    printf("{\"event\":\"start\",\"message\":\"Tracing network drops...\"}\n");`)
	} else {
		sb.WriteString(`    printf("Tracing network drops... Press Ctrl-C to stop.\n\n");`)
		sb.WriteString("\n")
		sb.WriteString(`    printf("%-12s %-10s %-6s %-22s %-22s %s\n",`)
		sb.WriteString("\n")
		sb.WriteString(`           "TIME", "TYPE", "CODE", "SRC", "DST", "DETAILS");`)
		sb.WriteString("\n")
		sb.WriteString(`    printf("─────────────────────────────────────────────────────────────────────────────────────────────────────────────\n");`)
	}

	sb.WriteString("\n}\n\n")
	return sb.String()
}

// generateDropTracepoint creates the kfree_skb tracepoint for packet drops.
func (g *ScriptGenerator) generateDropTracepoint() string {
	var sb strings.Builder

	// Tracepoint for packet drops
	sb.WriteString("tracepoint:skb:kfree_skb\n")

	// Add filter condition if IPs/CIDRs specified
	filter := g.buildFilterCondition()
	if filter != "" {
		sb.WriteString(filter)
	}

	sb.WriteString("{\n")

	// Extract packet info
	sb.WriteString(`    $skb = (struct sk_buff *)args->skbaddr;
    $reason = args->reason;

    // Skip non-drop events (reason 0-2 are not real drops)
    if ($reason <= 2) { return; }

    $protocol = $skb->protocol;

    // Only process IPv4 for now
    if (bswap($protocol) != 0x0800) { return; }

    $iph = (struct iphdr *)($skb->head + $skb->network_header);
    $saddr = ntop(2, $iph->saddr);
    $daddr = ntop(2, $iph->daddr);
    $ipproto = $iph->protocol;

    $sport = (uint16)0;
    $dport = (uint16)0;

    // Extract ports for TCP/UDP
    if ($ipproto == 6 || $ipproto == 17) {
        $transport_off = $skb->transport_header;
        if ($transport_off > 0 && $transport_off < 65535) {
            $th = $skb->head + $transport_off;
            $sport = bswap(*(uint16*)($th));
            $dport = bswap(*(uint16*)($th + 2));
        }
    }

`)

	// Generate output based on format
	if g.config.OutputJSON {
		sb.WriteString(g.generateJSONOutput())
	} else {
		sb.WriteString(g.generateTableOutput())
	}

	sb.WriteString("}\n\n")
	return sb.String()
}

// generateTableOutput generates printf for table format.
func (g *ScriptGenerator) generateTableOutput() string {
	return `    // Format source and destination with numeric reason code
    // Reason codes are kernel-version specific - see printed enum at start
    if ($sport > 0) {
        printf("%-12s %-10s %-6d %s:%-5d  ->  %s:%-5d %s\n",
               strftime("%H:%M:%S", nsecs),
               "DROP",
               $reason,
               $saddr, $sport,
               $daddr, $dport,
               ksym(args->location));
    } else {
        printf("%-12s %-10s %-6d %-22s %-22s %s\n",
               strftime("%H:%M:%S", nsecs),
               "DROP",
               $reason,
               $saddr,
               $daddr,
               ksym(args->location));
    }
`
}

// generateJSONOutput generates printf for JSON format.
func (g *ScriptGenerator) generateJSONOutput() string {
	return `    // Output JSON with numeric reason code
    // Reason codes are kernel-version specific - see printed enum at start
    printf("{\"time\":\"%s\",\"type\":\"DROP\",\"reason_code\":%d,\"src_ip\":\"%s\",\"src_port\":%d,\"dst_ip\":\"%s\",\"dst_port\":%d,\"location\":\"%s\"}\n",
           strftime("%H:%M:%S", nsecs),
           $reason,
           $saddr, $sport,
           $daddr, $dport,
           ksym(args->location));
`
}

// generateEndBlock creates the END block.
func (g *ScriptGenerator) generateEndBlock() string {
	if g.config.OutputJSON {
		return `END {
    printf("{\"event\":\"end\",\"message\":\"Trace complete\"}\n");
}
`
	}
	return `END {
    printf("\n─────────────────────────────────────────────────────────────────────────────────────────────────────────────\n");
    printf("Trace complete.\n");
}
`
}

// buildFilterCondition creates the bpftrace filter condition for IPs/CIDRs.
// SECURITY: IPs are converted to hex integers - no string interpolation of user input.
func (g *ScriptGenerator) buildFilterCondition() string {
	if len(g.config.FilterIPs) == 0 && len(g.config.FilterCIDRs) == 0 {
		return "" // No filter
	}

	var conditions []string

	// Add IP filters
	for _, ip := range g.config.FilterIPs {
		cond := g.ipToFilterCondition(ip)
		if cond != "" {
			conditions = append(conditions, cond)
		}
	}

	// Add CIDR filters
	for _, cidr := range g.config.FilterCIDRs {
		cond := g.cidrToFilterCondition(cidr)
		if cond != "" {
			conditions = append(conditions, cond)
		}
	}

	if len(conditions) == 0 {
		return ""
	}

	// Combine with OR - match if ANY filter matches
	combined := strings.Join(conditions, " || ")
	return fmt.Sprintf("/ %s /\n", combined)
}

// ipToFilterCondition converts a net.IP to a bpftrace filter condition.
// SECURITY: The IP is converted to a hex integer, preventing any injection.
// Output: ($saddr_raw == 0x0a000001 || $daddr_raw == 0x0a000001)
func (g *ScriptGenerator) ipToFilterCondition(ip net.IP) string {
	ipv4 := ip.To4()
	if ipv4 == nil {
		return "" // Skip IPv6 for now
	}

	// Convert to uint32 in network byte order (big endian)
	// This is safe: only hex digits can appear in the output
	ipHex := ipToHex(ipv4)

	// Match either source or destination
	// Note: We compare against the raw IP header fields (network byte order)
	return fmt.Sprintf("(((struct iphdr *)(@skb[args->skbaddr]->head + @skb[args->skbaddr]->network_header))->saddr == 0x%08x || ((struct iphdr *)(@skb[args->skbaddr]->head + @skb[args->skbaddr]->network_header))->daddr == 0x%08x)", ipHex, ipHex)
}

// cidrToFilterCondition converts a net.IPNet to a bpftrace filter condition.
// SECURITY: The network and mask are converted to hex integers.
// Output: ((saddr & mask) == network || (daddr & mask) == network)
func (g *ScriptGenerator) cidrToFilterCondition(cidr *net.IPNet) string {
	if cidr == nil {
		return ""
	}

	ipv4 := cidr.IP.To4()
	if ipv4 == nil {
		return "" // Skip IPv6 for now
	}

	// Get network address and mask as hex
	networkHex := ipToHex(ipv4)
	maskHex := ipToHex(net.IP(cidr.Mask).To4())

	// Match: (ip & mask) == network for either src or dst
	return fmt.Sprintf("((((struct iphdr *)(@skb[args->skbaddr]->head + @skb[args->skbaddr]->network_header))->saddr & 0x%08x) == 0x%08x || (((struct iphdr *)(@skb[args->skbaddr]->head + @skb[args->skbaddr]->network_header))->daddr & 0x%08x) == 0x%08x)",
		maskHex, networkHex, maskHex, networkHex)
}

// ipToHex converts an IPv4 address to a uint32 in network byte order.
// SECURITY: This function only outputs hex digits - no user input passes through.
func ipToHex(ip net.IP) uint32 {
	ipv4 := ip.To4()
	if ipv4 == nil {
		return 0
	}
	// Network byte order (big endian) - this matches how IPs are stored in IP headers
	return binary.BigEndian.Uint32(ipv4)
}

// DropReasonsCommand returns the command to fetch SKB drop reason enum from kernel.
// The enum values are kernel-version specific and must be read at runtime.
// This reads from the tracepoint format file which contains the enum definition.
func DropReasonsCommand() []string {
	return []string{
		"sh", "-c",
		`echo "=== SKB Drop Reason Codes (kernel-specific) ===" && ` +
			`cat /sys/kernel/debug/tracing/events/skb/kfree_skb/format 2>/dev/null | ` +
			`grep -A 200 "^print fmt:" | grep -oE "__print_symbolic.*reason," | ` +
			`sed 's/__print_symbolic.*{//; s/}.*//; s/, /\n/g' | ` +
			`grep -E "^[0-9]" | head -60 || ` +
			`echo "(Could not read drop reasons - requires debugfs mounted)"`,
	}
}
