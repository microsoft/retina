// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

package shell

import (
	"encoding/binary"
	"fmt"
	"net"
	"strings"
)

// ScriptGenerator generates bpftrace scripts for network tracing.
// SECURITY: All IP addresses are converted to hex representation to prevent injection.
type ScriptGenerator struct {
	config TraceConfig
}

// NewScriptGenerator creates a new script generator with the given config.
func NewScriptGenerator(config TraceConfig) *ScriptGenerator {
	return &ScriptGenerator{config: config}
}

// Generate creates the complete bpftrace script.
func (g *ScriptGenerator) Generate() string {
	var sb strings.Builder

	// Write script header
	sb.WriteString(g.generateHeader())

	// Write BEGIN block
	sb.WriteString(g.generateBeginBlock())

	// Write netfilter tracepoint (stores table/chain for enrichment)
	sb.WriteString(g.generateNetfilterTracepoint())

	// Write drop tracepoint (main output, enriched with netfilter info)
	sb.WriteString(g.generateDropTracepoint())

	// Write RST tracepoints
	sb.WriteString(g.generateRSTTracepoints())

	// Write socket error tracepoint
	sb.WriteString(g.generateSocketErrorTracepoint())

	// Write TCP retransmit tracepoint
	sb.WriteString(g.generateRetransmitTracepoint())

	// Write END block
	sb.WriteString(g.generateEndBlock())

	return sb.String()
}

// generateHeader creates the script header with comments.
// Note: No #include directives - bpftrace uses BTF for struct access.
func (g *ScriptGenerator) generateHeader() string {
	return `#!/usr/bin/env bpftrace
/*
 * Network Issue Tracer - Generated by retina nettrace
 * Traces:
 *   - Packet drops with reason codes
 *   - TCP RST sent/received (connection failures)
 *
 * Note: Uses BTF for struct access (no kernel headers needed)
 */

`
}

// generateBeginBlock creates the BEGIN block with initialization.
func (g *ScriptGenerator) generateBeginBlock() string {
	var sb strings.Builder

	sb.WriteString("BEGIN {\n")

	if g.config.OutputJSON {
		sb.WriteString(`    printf("{\"event\":\"start\",\"message\":\"Tracing network issues...\"}\n");`)
	} else {
		sb.WriteString(`    printf("Tracing network issues... Press Ctrl-C to stop.\n\n");`)
		sb.WriteString("\n")
		sb.WriteString(`    printf("%-12s %-10s %-18s %-18s %s\n",`)
		sb.WriteString("\n")
		sb.WriteString(`           "TIME", "TYPE", "REASON", "PROBE", "SRC -> DST");`)
		sb.WriteString("\n")
		sb.WriteString(`    printf("────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n");`)
	}

	sb.WriteString("\n}\n\n")
	return sb.String()
}

// generateNetfilterTracepoint would capture table/chain info from netfilter.
// Currently disabled because:
// - nft_do_chain (nftables) is in a kernel module without BTF data
// - ipt_do_table (legacy iptables) only works on legacy iptables systems
// The kfree_skb tracepoint still captures all drops with reason codes.
// TODO: Re-enable when we find a BTF-compatible probe point or use kprobe with manual struct parsing.
func (g *ScriptGenerator) generateNetfilterTracepoint() string {
	return "" // Disabled - see comment above
}

// generateDropTracepoint creates the kfree_skb tracepoint for packet drops.
func (g *ScriptGenerator) generateDropTracepoint() string {
	var sb strings.Builder

	// Tracepoint for packet drops
	// Note: No pre-filter here because we need to parse skb to get IPs.
	// IP filtering is done in the body after extracting addresses.
	sb.WriteString("tracepoint:skb:kfree_skb\n")
	sb.WriteString("{\n")

	// Extract packet info
	sb.WriteString(`    $skb = (struct sk_buff *)args->skbaddr;
    $reason = args->reason;

    // Skip non-drop events (reason 0-2 are not real drops)
    if ($reason <= 2) { return; }

    $protocol = $skb->protocol;

    // Only process IPv4 for now
    if (bswap($protocol) != 0x0800) { return; }

    $iph = (struct iphdr *)($skb->head + $skb->network_header);
    $saddr_raw = $iph->saddr;
    $daddr_raw = $iph->daddr;
    $saddr = ntop(2, $saddr_raw);
    $daddr = ntop(2, $daddr_raw);
    $ipproto = $iph->protocol;

`)

	// Add IP/CIDR filter inside the body if specified
	ipFilter := g.buildSkbIPFilterCondition()
	if ipFilter != "" {
		sb.WriteString(ipFilter)
	}

	sb.WriteString(`    $sport = (uint16)0;
    $dport = (uint16)0;

    // Extract ports for TCP/UDP
    if ($ipproto == 6 || $ipproto == 17) {
        $transport_off = $skb->transport_header;
        if ($transport_off > 0 && $transport_off < 65535) {
            $th = $skb->head + $transport_off;
            $sport = bswap(*(uint16*)($th));
            $dport = bswap(*(uint16*)($th + 2));
        }
    }

`)

	// Generate output based on format
	if g.config.OutputJSON {
		sb.WriteString(g.generateJSONOutput())
	} else {
		sb.WriteString(g.generateTableOutput())
	}

	sb.WriteString("}\n\n")
	return sb.String()
}

// generateRSTTracepoints creates tracepoints for TCP RST events.
func (g *ScriptGenerator) generateRSTTracepoints() string {
	var sb strings.Builder

	// TCP RST sent - when this host sends a RST
	sb.WriteString(g.generateRSTSentTracepoint())

	// TCP RST received - when this host receives a RST
	sb.WriteString(g.generateRSTReceivedTracepoint())

	return sb.String()
}

// generateRSTSentTracepoint creates the tcp_send_reset tracepoint.
func (g *ScriptGenerator) generateRSTSentTracepoint() string {
	var sb strings.Builder

	sb.WriteString("tracepoint:tcp:tcp_send_reset\n")
	sb.WriteString("{\n")

	// Only process IPv4 (family == 2)
	sb.WriteString(`    if (args->family != 2) { return; }

`)

	// Extract bytes into local vars first (required for BPF verifier)
	if g.hasIPFilter() {
		sb.WriteString(`    // Read IP bytes into local vars for filtering
    $s0 = args->saddr[0]; $s1 = args->saddr[1]; $s2 = args->saddr[2]; $s3 = args->saddr[3];
    $d0 = args->daddr[0]; $d1 = args->daddr[1]; $d2 = args->daddr[2]; $d3 = args->daddr[3];

`)
		// Add IP filter using local vars
		sb.WriteString(g.buildTCPIPFilterCheckFromLocalVars())
	}

	sb.WriteString(`    $saddr = ntop(2, args->saddr);
    $daddr = ntop(2, args->daddr);
    $sport = args->sport;
    $dport = args->dport;

`)

	if g.config.OutputJSON {
		sb.WriteString(`    printf("{\"time\":\"%s\",\"type\":\"RST_SENT\",\"probe\":\"tcp_send_reset\",\"src_ip\":\"%s\",\"src_port\":%d,\"dst_ip\":\"%s\",\"dst_port\":%d}\n",
           strftime("%H:%M:%S", nsecs),
           $saddr, $sport,
           $daddr, $dport);
`)
	} else {
		sb.WriteString(`    printf("%-12s %-10s %-18s %-18s %s:%-5d  ->  %s:%-5d\n",
           strftime("%H:%M:%S", nsecs),
           "RST_SENT",
           "-",
           "tcp_send_reset",
           $saddr, $sport,
           $daddr, $dport);
`)
	}

	sb.WriteString("}\n\n")
	return sb.String()
}

// generateRSTReceivedTracepoint creates the tcp_receive_reset tracepoint.
func (g *ScriptGenerator) generateRSTReceivedTracepoint() string {
	var sb strings.Builder

	sb.WriteString("tracepoint:tcp:tcp_receive_reset\n")
	sb.WriteString("{\n")

	// Only process IPv4 (family == 2)
	sb.WriteString(`    if (args->family != 2) { return; }

`)

	// Extract bytes into local vars first (required for BPF verifier)
	if g.hasIPFilter() {
		sb.WriteString(`    // Read IP bytes into local vars for filtering
    $s0 = args->saddr[0]; $s1 = args->saddr[1]; $s2 = args->saddr[2]; $s3 = args->saddr[3];
    $d0 = args->daddr[0]; $d1 = args->daddr[1]; $d2 = args->daddr[2]; $d3 = args->daddr[3];

`)
		// Add IP filter using local vars
		sb.WriteString(g.buildTCPIPFilterCheckFromLocalVars())
	}

	sb.WriteString(`    $saddr = ntop(2, args->saddr);
    $daddr = ntop(2, args->daddr);
    $sport = args->sport;
    $dport = args->dport;

`)

	if g.config.OutputJSON {
		sb.WriteString(`    printf("{\"time\":\"%s\",\"type\":\"RST_RECV\",\"probe\":\"tcp_receive_reset\",\"src_ip\":\"%s\",\"src_port\":%d,\"dst_ip\":\"%s\",\"dst_port\":%d}\n",
           strftime("%H:%M:%S", nsecs),
           $saddr, $sport,
           $daddr, $dport);
`)
	} else {
		sb.WriteString(`    printf("%-12s %-10s %-18s %-18s %s:%-5d  ->  %s:%-5d\n",
           strftime("%H:%M:%S", nsecs),
           "RST_RECV",
           "-",
           "tcp_receive_reset",
           $saddr, $sport,
           $daddr, $dport);
`)
	}

	sb.WriteString("}\n\n")
	return sb.String()
}

// generateSocketErrorTracepoint creates the inet_sk_error_report tracepoint.
// This captures socket errors like ECONNREFUSED, ETIMEDOUT, etc.
func (g *ScriptGenerator) generateSocketErrorTracepoint() string {
	var sb strings.Builder

	sb.WriteString("tracepoint:sock:inet_sk_error_report\n")
	sb.WriteString("{\n")

	// Only process IPv4 (family == 2) and skip error=0 (not a real error)
	sb.WriteString(`    if (args->family != 2) { return; }
    if (args->error == 0) { return; }  // Skip non-error events (socket cleanup)

`)

	// Extract bytes into local vars first (required for BPF verifier)
	if g.hasIPFilter() {
		sb.WriteString(`    // Read IP bytes into local vars for filtering
    $s0 = args->saddr[0]; $s1 = args->saddr[1]; $s2 = args->saddr[2]; $s3 = args->saddr[3];
    $d0 = args->daddr[0]; $d1 = args->daddr[1]; $d2 = args->daddr[2]; $d3 = args->daddr[3];

`)
		// Add IP filter using local vars
		sb.WriteString(g.buildTCPIPFilterCheckFromLocalVars())
	}

	sb.WriteString(`    $saddr = ntop(2, args->saddr);
    $daddr = ntop(2, args->daddr);
    $sport = args->sport;
    $dport = args->dport;
    $error = args->error;

`)

	if g.config.OutputJSON {
		// JSON output: use error code only (parsers can decode POSIX errno)
		sb.WriteString(`    printf("{\"time\":\"%s\",\"type\":\"SOCK_ERR\",\"reason_code\":%d,\"probe\":\"inet_sk_error_report\",\"src_ip\":\"%s\",\"src_port\":%d,\"dst_ip\":\"%s\",\"dst_port\":%d}\n",
           strftime("%H:%M:%S", nsecs),
           $error,
           $saddr, $sport,
           $daddr, $dport);
`)
	} else {
		// Table output: decode errno to human-readable name
		sb.WriteString(`    // Decode common socket errno values (POSIX standard)
    $errno_name = $error == 104 ? "ECONNRESET" :
                  $error == 110 ? "ETIMEDOUT" :
                  $error == 111 ? "ECONNREFUSED" :
                  $error == 113 ? "EHOSTUNREACH" :
                  $error == 101 ? "ENETUNREACH" :
                  $error == 99  ? "EADDRNOTAVAIL" :
                  $error == 112 ? "EHOSTDOWN" :
                  $error == 103 ? "ECONNABORTED" :
                  "UNKNOWN";

    printf("%-12s %-10s %-18s %-18s %s:%-5d  ->  %s:%-5d\n",
           strftime("%H:%M:%S", nsecs),
           "SOCK_ERR",
           $errno_name,
           "inet_sk_error_report",
           $saddr, $sport,
           $daddr, $dport);
`)
	}

	sb.WriteString("}\n\n")
	return sb.String()
}

// generateRetransmitTracepoint creates the tcp_retransmit_skb tracepoint.
// This captures TCP retransmissions which indicate packet loss or congestion.
func (g *ScriptGenerator) generateRetransmitTracepoint() string {
	var sb strings.Builder

	sb.WriteString("tracepoint:tcp:tcp_retransmit_skb\n")
	sb.WriteString("{\n")

	// Only process IPv4 (family == 2)
	sb.WriteString(`    if (args->family != 2) { return; }

`)

	// Extract bytes into local vars first (required for BPF verifier)
	if g.hasIPFilter() {
		sb.WriteString(`    // Read IP bytes into local vars for filtering
    $s0 = args->saddr[0]; $s1 = args->saddr[1]; $s2 = args->saddr[2]; $s3 = args->saddr[3];
    $d0 = args->daddr[0]; $d1 = args->daddr[1]; $d2 = args->daddr[2]; $d3 = args->daddr[3];

`)
		// Add IP filter using local vars
		sb.WriteString(g.buildTCPIPFilterCheckFromLocalVars())
	}

	sb.WriteString(`    $saddr = ntop(2, args->saddr);
    $daddr = ntop(2, args->daddr);
    $sport = args->sport;
    $dport = args->dport;
    $state = args->state;

`)

	if g.config.OutputJSON {
		sb.WriteString(`    printf("{\"time\":\"%s\",\"type\":\"RETRANS\",\"reason_code\":%d,\"probe\":\"tcp_retransmit_skb\",\"src_ip\":\"%s\",\"src_port\":%d,\"dst_ip\":\"%s\",\"dst_port\":%d}\n",
           strftime("%H:%M:%S", nsecs),
           $state,
           $saddr, $sport,
           $daddr, $dport);
`)
	} else {
		sb.WriteString(`    printf("%-12s %-10s %-18d %-18s %s:%-5d  ->  %s:%-5d\n",
           strftime("%H:%M:%S", nsecs),
           "RETRANS",
           $state,
           "tcp_retransmit_skb",
           $saddr, $sport,
           $daddr, $dport);
`)
	}

	sb.WriteString("}\n\n")
	return sb.String()
}

// buildTCPIPFilterCheck creates an if-statement to filter by IP inside TCP tracepoint bodies.
// Uses byte-by-byte comparison since TCP tracepoints have args->saddr as uint8[4].
// SECURITY: IPs are converted to integer byte values - no string interpolation.
func (g *ScriptGenerator) buildTCPIPFilterCheck() string {
	if len(g.config.FilterIPs) == 0 && len(g.config.FilterCIDRs) == 0 {
		return "" // No filter
	}

	var conditions []string

	// Add IP filters - compare byte by byte
	for _, ip := range g.config.FilterIPs {
		ipv4 := ip.To4()
		if ipv4 == nil {
			continue
		}
		// Match either source or destination, byte by byte
		conditions = append(conditions, fmt.Sprintf(
			"((args->saddr[0] == %d && args->saddr[1] == %d && args->saddr[2] == %d && args->saddr[3] == %d) || (args->daddr[0] == %d && args->daddr[1] == %d && args->daddr[2] == %d && args->daddr[3] == %d))",
			ipv4[0], ipv4[1], ipv4[2], ipv4[3],
			ipv4[0], ipv4[1], ipv4[2], ipv4[3]))
	}

	// Add CIDR filters - mask and compare byte by byte
	for _, cidr := range g.config.FilterCIDRs {
		if cidr == nil {
			continue
		}
		ipv4 := cidr.IP.To4()
		mask := cidr.Mask
		if ipv4 == nil || len(mask) != 4 {
			continue
		}
		// (byte & mask) == network_byte for each byte
		conditions = append(conditions, fmt.Sprintf(
			"(((args->saddr[0] & %d) == %d && (args->saddr[1] & %d) == %d && (args->saddr[2] & %d) == %d && (args->saddr[3] & %d) == %d) || ((args->daddr[0] & %d) == %d && (args->daddr[1] & %d) == %d && (args->daddr[2] & %d) == %d && (args->daddr[3] & %d) == %d))",
			mask[0], ipv4[0], mask[1], ipv4[1], mask[2], ipv4[2], mask[3], ipv4[3],
			mask[0], ipv4[0], mask[1], ipv4[1], mask[2], ipv4[2], mask[3], ipv4[3]))
	}

	if len(conditions) == 0 {
		return ""
	}

	// Generate an if-statement that returns early if no condition matches
	combined := strings.Join(conditions, " || ")
	return fmt.Sprintf("    // IP/CIDR filter: skip if not matching\n    if (!(%s)) { return; }\n\n", combined)
}

// hasIPFilter returns true if any IP or CIDR filter is configured.
func (g *ScriptGenerator) hasIPFilter() bool {
	return len(g.config.FilterIPs) > 0 || len(g.config.FilterCIDRs) > 0
}

// buildTCPIPFilterCheckFromLocalVars creates a filter using local vars $s0-$s3 and $d0-$d3.
// This is required because the BPF verifier doesn't allow reading from different
// offsets of args after a probe_read. We read bytes into local vars first, then filter.
// SECURITY: IPs are converted to integer byte values - no string interpolation.
func (g *ScriptGenerator) buildTCPIPFilterCheckFromLocalVars() string {
	if len(g.config.FilterIPs) == 0 && len(g.config.FilterCIDRs) == 0 {
		return "" // No filter
	}

	var conditions []string

	// Add IP filters - compare using local vars
	for _, ip := range g.config.FilterIPs {
		ipv4 := ip.To4()
		if ipv4 == nil {
			continue
		}
		// Match either source or destination using local vars
		conditions = append(conditions, fmt.Sprintf(
			"(($s0 == %d && $s1 == %d && $s2 == %d && $s3 == %d) || ($d0 == %d && $d1 == %d && $d2 == %d && $d3 == %d))",
			ipv4[0], ipv4[1], ipv4[2], ipv4[3],
			ipv4[0], ipv4[1], ipv4[2], ipv4[3]))
	}

	// Add CIDR filters - mask and compare using local vars
	for _, cidr := range g.config.FilterCIDRs {
		if cidr == nil {
			continue
		}
		ipv4 := cidr.IP.To4()
		mask := cidr.Mask
		if ipv4 == nil || len(mask) != 4 {
			continue
		}
		// (byte & mask) == network_byte for each byte
		conditions = append(conditions, fmt.Sprintf(
			"((($s0 & %d) == %d && ($s1 & %d) == %d && ($s2 & %d) == %d && ($s3 & %d) == %d) || (($d0 & %d) == %d && ($d1 & %d) == %d && ($d2 & %d) == %d && ($d3 & %d) == %d))",
			mask[0], ipv4[0], mask[1], ipv4[1], mask[2], ipv4[2], mask[3], ipv4[3],
			mask[0], ipv4[0], mask[1], ipv4[1], mask[2], ipv4[2], mask[3], ipv4[3]))
	}

	if len(conditions) == 0 {
		return ""
	}

	// Generate an if-statement that returns early if no condition matches
	combined := strings.Join(conditions, " || ")
	return fmt.Sprintf("    // IP/CIDR filter: skip if not matching\n    if (!(%s)) { return; }\n\n", combined)
}

// buildTCPFilterCondition is deprecated - use buildTCPIPFilterCheck instead.
// Kept for backwards compatibility with tests.
func (g *ScriptGenerator) buildTCPFilterCondition() string {
	if len(g.config.FilterIPs) == 0 && len(g.config.FilterCIDRs) == 0 {
		return "" // No filter
	}

	var conditions []string

	// Add IP filters - for TCP tracepoints, saddr/daddr are __u8[4] arrays
	for _, ip := range g.config.FilterIPs {
		cond := g.ipToTCPFilterCondition(ip)
		if cond != "" {
			conditions = append(conditions, cond)
		}
	}

	// Add CIDR filters
	for _, cidr := range g.config.FilterCIDRs {
		cond := g.cidrToTCPFilterCondition(cidr)
		if cond != "" {
			conditions = append(conditions, cond)
		}
	}

	if len(conditions) == 0 {
		return ""
	}

	combined := strings.Join(conditions, " || ")
	return fmt.Sprintf("/ %s /\n", combined)
}

// ipToTCPFilterCondition converts a net.IP to a filter for TCP tracepoints.
// TCP tracepoints store IPs as __u8[4] arrays.
func (g *ScriptGenerator) ipToTCPFilterCondition(ip net.IP) string {
	ipv4 := ip.To4()
	if ipv4 == nil {
		return ""
	}

	// For TCP tracepoints, args->saddr and args->daddr are uint8[4] byte arrays.
	// bpftrace cannot cast uint8[4] to uint32*, so we compare byte-by-byte.
	// Each byte is compared as: (args->saddr[i] == byte_value)
	return fmt.Sprintf("((args->saddr[0] == %d && args->saddr[1] == %d && args->saddr[2] == %d && args->saddr[3] == %d) || (args->daddr[0] == %d && args->daddr[1] == %d && args->daddr[2] == %d && args->daddr[3] == %d))",
		ipv4[0], ipv4[1], ipv4[2], ipv4[3],
		ipv4[0], ipv4[1], ipv4[2], ipv4[3])
}

// cidrToTCPFilterCondition converts a net.IPNet to a filter for TCP tracepoints.
// For CIDR matching on uint8[4] arrays, we compare each byte with the masked value.
func (g *ScriptGenerator) cidrToTCPFilterCondition(cidr *net.IPNet) string {
	if cidr == nil {
		return ""
	}

	ipv4 := cidr.IP.To4()
	mask := cidr.Mask
	if ipv4 == nil || len(mask) != 4 {
		return ""
	}

	// For CIDR matching, we compare (byte & mask_byte) == network_byte for each byte
	// Example: 10.224.0.0/16 means mask=[255,255,0,0], network=[10,224,0,0]
	return fmt.Sprintf("(((args->saddr[0] & %d) == %d && (args->saddr[1] & %d) == %d && (args->saddr[2] & %d) == %d && (args->saddr[3] & %d) == %d) || ((args->daddr[0] & %d) == %d && (args->daddr[1] & %d) == %d && (args->daddr[2] & %d) == %d && (args->daddr[3] & %d) == %d))",
		mask[0], ipv4[0], mask[1], ipv4[1], mask[2], ipv4[2], mask[3], ipv4[3],
		mask[0], ipv4[0], mask[1], ipv4[1], mask[2], ipv4[2], mask[3], ipv4[3])
}

// generateTableOutput generates printf for table format.
func (g *ScriptGenerator) generateTableOutput() string {
	return `    // Format source and destination with numeric reason code
    if ($sport > 0) {
        printf("%-12s %-10s %-18d %-18s %s:%-5d  ->  %s:%-5d\n",
               strftime("%H:%M:%S", nsecs),
               "DROP",
               $reason,
               "kfree_skb",
               $saddr, $sport,
               $daddr, $dport);
    } else {
        printf("%-12s %-10s %-18d %-18s %s  ->  %s\n",
               strftime("%H:%M:%S", nsecs),
               "DROP",
               $reason,
               "kfree_skb",
               $saddr,
               $daddr);
    }
`
}

// generateJSONOutput generates printf for JSON format.
func (g *ScriptGenerator) generateJSONOutput() string {
	return `    // Output JSON with numeric reason code
    printf("{\"time\":\"%s\",\"type\":\"DROP\",\"reason_code\":%d,\"probe\":\"kfree_skb\",\"src_ip\":\"%s\",\"src_port\":%d,\"dst_ip\":\"%s\",\"dst_port\":%d}\n",
           strftime("%H:%M:%S", nsecs),
           $reason,
           $saddr, $sport,
           $daddr, $dport);
`
}

// generateEndBlock creates the END block.
func (g *ScriptGenerator) generateEndBlock() string {
	if g.config.OutputJSON {
		return `END {
    printf("{\"event\":\"end\",\"message\":\"Trace complete\"}\n");
}
`
	}
	return `END {
    printf("\n────────────────────────────────────────────────────────────────────────────────────────────────────────────\n");
    printf("Trace complete.\n");
}
`
}

// buildSkbIPFilterCondition creates an if-statement to filter by IP inside kfree_skb body.
// This is used instead of a pre-filter because we need to parse the skb to get the IPs.
// SECURITY: IPs are converted to hex integers - no string interpolation of user input.
func (g *ScriptGenerator) buildSkbIPFilterCondition() string {
	if len(g.config.FilterIPs) == 0 && len(g.config.FilterCIDRs) == 0 {
		return "" // No filter
	}

	var conditions []string

	// Add IP filters - compare against the raw uint32 IP values
	for _, ip := range g.config.FilterIPs {
		ipv4 := ip.To4()
		if ipv4 == nil {
			continue
		}
		ipHex := ipToHex(ipv4)
		// Match either source or destination (network byte order)
		conditions = append(conditions, fmt.Sprintf("($saddr_raw == 0x%08x || $daddr_raw == 0x%08x)", ipHex, ipHex))
	}

	// Add CIDR filters - mask and compare
	for _, cidr := range g.config.FilterCIDRs {
		if cidr == nil {
			continue
		}
		ipv4 := cidr.IP.To4()
		if ipv4 == nil {
			continue
		}
		networkHex := ipToHex(ipv4)
		maskHex := ipToHex(net.IP(cidr.Mask).To4())
		conditions = append(conditions, fmt.Sprintf("(($saddr_raw & 0x%08x) == 0x%08x || ($daddr_raw & 0x%08x) == 0x%08x)",
			maskHex, networkHex, maskHex, networkHex))
	}

	if len(conditions) == 0 {
		return ""
	}

	// Generate an if-statement that returns early if no condition matches
	combined := strings.Join(conditions, " || ")
	return fmt.Sprintf("    // IP/CIDR filter: skip if not matching\n    if (!(%s)) { return; }\n\n", combined)
}

// Note: ipToFilterCondition and cidrToFilterCondition are no longer used for kfree_skb.
// For kfree_skb, we use buildSkbIPFilterCondition() which filters inside the body.
// For TCP tracepoints, we use ipToTCPFilterCondition() and cidrToTCPFilterCondition().

// ipToHex converts an IPv4 address to a uint32 in network byte order.
// SECURITY: This function only outputs hex digits - no user input passes through.
func ipToHex(ip net.IP) uint32 {
	ipv4 := ip.To4()
	if ipv4 == nil {
		return 0
	}
	// Network byte order (big endian) - this matches how IPs are stored in IP headers
	return binary.BigEndian.Uint32(ipv4)
}

// DropReasonsCommand returns the command to fetch SKB drop reason enum from kernel.
// The enum values are kernel-version specific and must be read at runtime.
// This reads from the tracepoint format file which contains the enum definition.
func DropReasonsCommand() []string {
	return []string{
		"sh", "-c",
		`echo "=== SKB Drop Reason Codes (kernel-specific) ===" && ` +
			`cat /sys/kernel/debug/tracing/events/skb/kfree_skb/format 2>/dev/null | ` +
			`grep -oE '\{ [0-9]+, "[^"]+" \}' | ` +
			`sed 's/{ \([0-9]*\), "\([^"]*\)" }/\1 = \2/' | ` +
			`head -30 || ` +
			`echo "(Could not read drop reasons - requires debugfs mounted)"`,
	}
}
