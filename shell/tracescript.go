// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

package shell

import (
	"encoding/binary"
	"fmt"
	"net"
	"strings"
)

// ScriptGenerator generates bpftrace scripts for network tracing.
// SECURITY: All IP addresses are converted to hex representation to prevent injection.
type ScriptGenerator struct {
	config TraceConfig
}

// NewScriptGenerator creates a new script generator with the given config.
func NewScriptGenerator(config TraceConfig) *ScriptGenerator {
	return &ScriptGenerator{config: config}
}

// Generate creates the complete bpftrace script.
func (g *ScriptGenerator) Generate() string {
	var sb strings.Builder

	// Write script header
	sb.WriteString(g.generateHeader())

	// Write BEGIN block
	sb.WriteString(g.generateBeginBlock())

	// Write netfilter tracepoint (stores table/chain for enrichment)
	sb.WriteString(g.generateNetfilterTracepoint())

	// Write drop tracepoint (main output, enriched with netfilter info)
	sb.WriteString(g.generateDropTracepoint())

	// Write RST tracepoints
	sb.WriteString(g.generateRSTTracepoints())

	// Write END block
	sb.WriteString(g.generateEndBlock())

	return sb.String()
}

// generateHeader creates the script header with comments.
// Note: No #include directives - bpftrace uses BTF for struct access.
func (g *ScriptGenerator) generateHeader() string {
	return `#!/usr/bin/env bpftrace
/*
 * Network Issue Tracer - Generated by retina nettrace
 * Traces:
 *   - Packet drops with reason codes
 *   - TCP RST sent/received (connection failures)
 *
 * Note: Uses BTF for struct access (no kernel headers needed)
 */

`
}

// generateBeginBlock creates the BEGIN block with initialization.
func (g *ScriptGenerator) generateBeginBlock() string {
	var sb strings.Builder

	sb.WriteString("BEGIN {\n")

	if g.config.OutputJSON {
		sb.WriteString(`    printf("{\"event\":\"start\",\"message\":\"Tracing network issues...\"}\n");`)
	} else {
		sb.WriteString(`    printf("Tracing network issues... Press Ctrl-C to stop.\n\n");`)
		sb.WriteString("\n")
		sb.WriteString(`    printf("%-12s %-10s %-6s %-18s %s\n",`)
		sb.WriteString("\n")
		sb.WriteString(`           "TIME", "TYPE", "REASON", "PROBE", "SRC -> DST");`)
		sb.WriteString("\n")
		sb.WriteString(`    printf("──────────────────────────────────────────────────────────────────────────────────────────────────────────\n");`)
	}

	sb.WriteString("\n}\n\n")
	return sb.String()
}

// generateNetfilterTracepoint would capture table/chain info from netfilter.
// Currently disabled because:
// - nft_do_chain (nftables) is in a kernel module without BTF data
// - ipt_do_table (legacy iptables) only works on legacy iptables systems
// The kfree_skb tracepoint still captures all drops with reason codes.
// TODO: Re-enable when we find a BTF-compatible probe point or use kprobe with manual struct parsing.
func (g *ScriptGenerator) generateNetfilterTracepoint() string {
	return "" // Disabled - see comment above
}

// generateDropTracepoint creates the kfree_skb tracepoint for packet drops.
func (g *ScriptGenerator) generateDropTracepoint() string {
	var sb strings.Builder

	// Tracepoint for packet drops
	sb.WriteString("tracepoint:skb:kfree_skb\n")

	// Add filter condition if IPs/CIDRs specified
	filter := g.buildFilterCondition()
	if filter != "" {
		sb.WriteString(filter)
	}

	sb.WriteString("{\n")

	// Extract packet info
	sb.WriteString(`    $skb = (struct sk_buff *)args->skbaddr;
    $reason = args->reason;

    // Skip non-drop events (reason 0-2 are not real drops)
    if ($reason <= 2) { return; }

    $protocol = $skb->protocol;

    // Only process IPv4 for now
    if (bswap($protocol) != 0x0800) { return; }

    $iph = (struct iphdr *)($skb->head + $skb->network_header);
    $saddr = ntop(2, $iph->saddr);
    $daddr = ntop(2, $iph->daddr);
    $ipproto = $iph->protocol;

    $sport = (uint16)0;
    $dport = (uint16)0;

    // Extract ports for TCP/UDP
    if ($ipproto == 6 || $ipproto == 17) {
        $transport_off = $skb->transport_header;
        if ($transport_off > 0 && $transport_off < 65535) {
            $th = $skb->head + $transport_off;
            $sport = bswap(*(uint16*)($th));
            $dport = bswap(*(uint16*)($th + 2));
        }
    }

`)

	// Generate output based on format
	if g.config.OutputJSON {
		sb.WriteString(g.generateJSONOutput())
	} else {
		sb.WriteString(g.generateTableOutput())
	}

	sb.WriteString("}\n\n")
	return sb.String()
}

// generateRSTTracepoints creates tracepoints for TCP RST events.
func (g *ScriptGenerator) generateRSTTracepoints() string {
	var sb strings.Builder

	// TCP RST sent - when this host sends a RST
	sb.WriteString(g.generateRSTSentTracepoint())

	// TCP RST received - when this host receives a RST
	sb.WriteString(g.generateRSTReceivedTracepoint())

	return sb.String()
}

// generateRSTSentTracepoint creates the tcp_send_reset tracepoint.
func (g *ScriptGenerator) generateRSTSentTracepoint() string {
	var sb strings.Builder

	sb.WriteString("tracepoint:tcp:tcp_send_reset\n")

	// Add filter - tcp tracepoints have different args than skb
	filter := g.buildTCPFilterCondition()
	if filter != "" {
		sb.WriteString(filter)
	}

	sb.WriteString("{\n")

	// Only process IPv4 (family == 2)
	sb.WriteString(`    if (args->family != 2) { return; }

    $saddr = ntop(2, args->saddr);
    $daddr = ntop(2, args->daddr);
    $sport = args->sport;
    $dport = args->dport;

`)

	if g.config.OutputJSON {
		sb.WriteString(`    printf("{\"time\":\"%s\",\"type\":\"RST_SENT\",\"probe\":\"tcp_send_reset\",\"src_ip\":\"%s\",\"src_port\":%d,\"dst_ip\":\"%s\",\"dst_port\":%d}\n",
           strftime("%H:%M:%S", nsecs),
           $saddr, $sport,
           $daddr, $dport);
`)
	} else {
		sb.WriteString(`    printf("%-12s %-10s %-6s %-18s %s:%-5d  ->  %s:%-5d\n",
           strftime("%H:%M:%S", nsecs),
           "RST_SENT",
           "-",
           "tcp_send_reset",
           $saddr, $sport,
           $daddr, $dport);
`)
	}

	sb.WriteString("}\n\n")
	return sb.String()
}

// generateRSTReceivedTracepoint creates the tcp_receive_reset tracepoint.
func (g *ScriptGenerator) generateRSTReceivedTracepoint() string {
	var sb strings.Builder

	sb.WriteString("tracepoint:tcp:tcp_receive_reset\n")

	// Add filter
	filter := g.buildTCPFilterCondition()
	if filter != "" {
		sb.WriteString(filter)
	}

	sb.WriteString("{\n")

	// Only process IPv4 (family == 2)
	sb.WriteString(`    if (args->family != 2) { return; }

    $saddr = ntop(2, args->saddr);
    $daddr = ntop(2, args->daddr);
    $sport = args->sport;
    $dport = args->dport;

`)

	if g.config.OutputJSON {
		sb.WriteString(`    printf("{\"time\":\"%s\",\"type\":\"RST_RECV\",\"probe\":\"tcp_receive_reset\",\"src_ip\":\"%s\",\"src_port\":%d,\"dst_ip\":\"%s\",\"dst_port\":%d}\n",
           strftime("%H:%M:%S", nsecs),
           $saddr, $sport,
           $daddr, $dport);
`)
	} else {
		sb.WriteString(`    printf("%-12s %-10s %-6s %-18s %s:%-5d  ->  %s:%-5d\n",
           strftime("%H:%M:%S", nsecs),
           "RST_RECV",
           "-",
           "tcp_receive_reset",
           $saddr, $sport,
           $daddr, $dport);
`)
	}

	sb.WriteString("}\n\n")
	return sb.String()
}

// buildTCPFilterCondition creates filter for TCP tracepoints (different args structure).
// TCP tracepoints have args->saddr[4] and args->daddr[4] as byte arrays.
func (g *ScriptGenerator) buildTCPFilterCondition() string {
	if len(g.config.FilterIPs) == 0 && len(g.config.FilterCIDRs) == 0 {
		return "" // No filter
	}

	var conditions []string

	// Add IP filters - for TCP tracepoints, saddr/daddr are __u8[4] arrays
	for _, ip := range g.config.FilterIPs {
		cond := g.ipToTCPFilterCondition(ip)
		if cond != "" {
			conditions = append(conditions, cond)
		}
	}

	// Add CIDR filters
	for _, cidr := range g.config.FilterCIDRs {
		cond := g.cidrToTCPFilterCondition(cidr)
		if cond != "" {
			conditions = append(conditions, cond)
		}
	}

	if len(conditions) == 0 {
		return ""
	}

	combined := strings.Join(conditions, " || ")
	return fmt.Sprintf("/ %s /\n", combined)
}

// ipToTCPFilterCondition converts a net.IP to a filter for TCP tracepoints.
// TCP tracepoints store IPs as __u8[4] arrays, which bpftrace reads as uint32.
func (g *ScriptGenerator) ipToTCPFilterCondition(ip net.IP) string {
	ipv4 := ip.To4()
	if ipv4 == nil {
		return ""
	}

	// For TCP tracepoints, args->saddr is __u8[4] - need to compare each byte or cast
	// bpftrace can read the 4-byte array as a uint32 pointer
	ipHex := ipToHex(ipv4)
	return fmt.Sprintf("(*(uint32*)args->saddr == 0x%08x || *(uint32*)args->daddr == 0x%08x)", ipHex, ipHex)
}

// cidrToTCPFilterCondition converts a net.IPNet to a filter for TCP tracepoints.
func (g *ScriptGenerator) cidrToTCPFilterCondition(cidr *net.IPNet) string {
	if cidr == nil {
		return ""
	}

	ipv4 := cidr.IP.To4()
	if ipv4 == nil {
		return ""
	}

	networkHex := ipToHex(ipv4)
	maskHex := ipToHex(net.IP(cidr.Mask).To4())

	return fmt.Sprintf("((*(uint32*)args->saddr & 0x%08x) == 0x%08x || (*(uint32*)args->daddr & 0x%08x) == 0x%08x)",
		maskHex, networkHex, maskHex, networkHex)
}

// generateTableOutput generates printf for table format.
func (g *ScriptGenerator) generateTableOutput() string {
	return `    // Format source and destination with numeric reason code
    if ($sport > 0) {
        printf("%-12s %-10s %-6d %-18s %s:%-5d  ->  %s:%-5d\n",
               strftime("%H:%M:%S", nsecs),
               "DROP",
               $reason,
               "kfree_skb",
               $saddr, $sport,
               $daddr, $dport);
    } else {
        printf("%-12s %-10s %-6d %-18s %s  ->  %s\n",
               strftime("%H:%M:%S", nsecs),
               "DROP",
               $reason,
               "kfree_skb",
               $saddr,
               $daddr);
    }
`
}

// generateJSONOutput generates printf for JSON format.
func (g *ScriptGenerator) generateJSONOutput() string {
	return `    // Output JSON with numeric reason code
    printf("{\"time\":\"%s\",\"type\":\"DROP\",\"reason_code\":%d,\"probe\":\"kfree_skb\",\"src_ip\":\"%s\",\"src_port\":%d,\"dst_ip\":\"%s\",\"dst_port\":%d}\n",
           strftime("%H:%M:%S", nsecs),
           $reason,
           $saddr, $sport,
           $daddr, $dport);
`
}

// generateEndBlock creates the END block.
func (g *ScriptGenerator) generateEndBlock() string {
	if g.config.OutputJSON {
		return `END {
    printf("{\"event\":\"end\",\"message\":\"Trace complete\"}\n");
}
`
	}
	return `END {
    printf("\n────────────────────────────────────────────────────────────────────────────────────────────────────────────\n");
    printf("Trace complete.\n");
}
`
}

// buildFilterCondition creates the bpftrace filter condition for IPs/CIDRs.
// SECURITY: IPs are converted to hex integers - no string interpolation of user input.
func (g *ScriptGenerator) buildFilterCondition() string {
	if len(g.config.FilterIPs) == 0 && len(g.config.FilterCIDRs) == 0 {
		return "" // No filter
	}

	var conditions []string

	// Add IP filters
	for _, ip := range g.config.FilterIPs {
		cond := g.ipToFilterCondition(ip)
		if cond != "" {
			conditions = append(conditions, cond)
		}
	}

	// Add CIDR filters
	for _, cidr := range g.config.FilterCIDRs {
		cond := g.cidrToFilterCondition(cidr)
		if cond != "" {
			conditions = append(conditions, cond)
		}
	}

	if len(conditions) == 0 {
		return ""
	}

	// Combine with OR - match if ANY filter matches
	combined := strings.Join(conditions, " || ")
	return fmt.Sprintf("/ %s /\n", combined)
}

// ipToFilterCondition converts a net.IP to a bpftrace filter condition.
// SECURITY: The IP is converted to a hex integer, preventing any injection.
// Output: ($saddr_raw == 0x0a000001 || $daddr_raw == 0x0a000001)
func (g *ScriptGenerator) ipToFilterCondition(ip net.IP) string {
	ipv4 := ip.To4()
	if ipv4 == nil {
		return "" // Skip IPv6 for now
	}

	// Convert to uint32 in network byte order (big endian)
	// This is safe: only hex digits can appear in the output
	ipHex := ipToHex(ipv4)

	// Match either source or destination
	// Note: We compare against the raw IP header fields (network byte order)
	return fmt.Sprintf("(((struct iphdr *)(@skb[args->skbaddr]->head + @skb[args->skbaddr]->network_header))->saddr == 0x%08x || ((struct iphdr *)(@skb[args->skbaddr]->head + @skb[args->skbaddr]->network_header))->daddr == 0x%08x)", ipHex, ipHex)
}

// cidrToFilterCondition converts a net.IPNet to a bpftrace filter condition.
// SECURITY: The network and mask are converted to hex integers.
// Output: ((saddr & mask) == network || (daddr & mask) == network)
func (g *ScriptGenerator) cidrToFilterCondition(cidr *net.IPNet) string {
	if cidr == nil {
		return ""
	}

	ipv4 := cidr.IP.To4()
	if ipv4 == nil {
		return "" // Skip IPv6 for now
	}

	// Get network address and mask as hex
	networkHex := ipToHex(ipv4)
	maskHex := ipToHex(net.IP(cidr.Mask).To4())

	// Match: (ip & mask) == network for either src or dst
	return fmt.Sprintf("((((struct iphdr *)(@skb[args->skbaddr]->head + @skb[args->skbaddr]->network_header))->saddr & 0x%08x) == 0x%08x || (((struct iphdr *)(@skb[args->skbaddr]->head + @skb[args->skbaddr]->network_header))->daddr & 0x%08x) == 0x%08x)",
		maskHex, networkHex, maskHex, networkHex)
}

// ipToHex converts an IPv4 address to a uint32 in network byte order.
// SECURITY: This function only outputs hex digits - no user input passes through.
func ipToHex(ip net.IP) uint32 {
	ipv4 := ip.To4()
	if ipv4 == nil {
		return 0
	}
	// Network byte order (big endian) - this matches how IPs are stored in IP headers
	return binary.BigEndian.Uint32(ipv4)
}

// DropReasonsCommand returns the command to fetch SKB drop reason enum from kernel.
// The enum values are kernel-version specific and must be read at runtime.
// This reads from the tracepoint format file which contains the enum definition.
func DropReasonsCommand() []string {
	return []string{
		"sh", "-c",
		`echo "=== SKB Drop Reason Codes (kernel-specific) ===" && ` +
			`cat /sys/kernel/debug/tracing/events/skb/kfree_skb/format 2>/dev/null | ` +
			`grep -oE '\{ [0-9]+, "[^"]+" \}' | ` +
			`sed 's/{ \([0-9]*\), "\([^"]*\)" }/\1 = \2/' | ` +
			`head -30 || ` +
			`echo "(Could not read drop reasons - requires debugfs mounted)"`,
	}
}
